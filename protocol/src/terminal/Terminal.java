/*
 * Sistemas de Telecomunicacoes 
 *          2017/2018
 */
package terminal;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.util.HashMap;
import javax.swing.JFileChooser;
import protocol.Callbacks;
import protocol.GoBackN;
import protocol.SelectiveRepeat;
import protocol.Simplex_rcv;
import protocol.Simplex_snd;
import protocol.StopWait;
import protocol.Utopian_rcv;
import protocol.Utopian_snd;
import simulator.Event;
import simulator.Frame;
import simulator.Log;

/**
 * Main classe of the Protocol terminal, implements the GUI and maintains the
 * communication interface to the channel, virtualizing the communication with
 * the protocol object through the Callbacks and Simulator interfaces.
 *
 * @author lflb@fct.unl.pt
 */
public class Terminal extends javax.swing.JFrame implements Log, Simulator {

    private static final int ACK_TIMER_ID = -1;
    private static final int DATA_TIMER_ID = 1;

    /**
     * Interval that the protocol waits for a data frame before sending an ACK
     */
    private static final int ACK_TIMEOUT = 1;

    /**
     * Creates a new form Terminal
     */
    public Terminal() {
        initComponents();
        running = false;
        s = null;
        conn = null;
        proto = null;
        net = null;
        time = Event.UNDEF_TIME;
        ack_timer_on = false;
        timer_on = new HashMap<>();
        transmitted_data= new HashMap<>();
        sending_data= false;
        last_nak= -1;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jPanel1 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jTextName = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jTextIP = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jTextPort = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        jButtonClear = new javax.swing.JButton();
        jToggleButtonConnect = new javax.swing.JToggleButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jTextSndWND = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jTextRcvWND = new javax.swing.JTextField();
        jComboBoxProtocol = new javax.swing.JComboBox();
        jPanel3 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jTextSndPackets = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jTextTimeout = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        jTextMaxSeq = new javax.swing.JTextField();
        jPanel4 = new javax.swing.JPanel();
        jToggleButtonToFile = new javax.swing.JToggleButton();
        jTextWriteFile = new javax.swing.JTextField();
        jCheckBoxDebug = new javax.swing.JCheckBox();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        jFileChooser1.setDialogTitle("Select a file for writing the log");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Protocol by 50236, 50292 and 50732");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));

        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.X_AXIS));

        jLabel5.setText("Name");
        jPanel1.add(jLabel5);

        jTextName.setEditable(false);
        jTextName.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jTextName.setText("  ");
        jTextName.setMaximumSize(new java.awt.Dimension(30, 27));
        jTextName.setPreferredSize(new java.awt.Dimension(25, 28));
        jPanel1.add(jTextName);

        jLabel1.setText("  IP");
        jPanel1.add(jLabel1);

        jTextIP.setText("127.0.0.1");
        jTextIP.setMaximumSize(new java.awt.Dimension(100, 28));
        jTextIP.setPreferredSize(new java.awt.Dimension(100, 28));
        jPanel1.add(jTextIP);

        jLabel2.setText("  Port");
        jPanel1.add(jLabel2);

        jTextPort.setText("20000");
        jTextPort.setMaximumSize(new java.awt.Dimension(70, 28));
        jTextPort.setPreferredSize(new java.awt.Dimension(65, 28));
        jPanel1.add(jTextPort);

        jLabel6.setText("   ");
        jPanel1.add(jLabel6);

        jButtonClear.setBackground(new java.awt.Color(255, 255, 204));
        jButtonClear.setText("Clear");
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });
        jPanel1.add(jButtonClear);

        jToggleButtonConnect.setText("Connect");
        jToggleButtonConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButtonConnectActionPerformed(evt);
            }
        });
        jPanel1.add(jToggleButtonConnect);

        getContentPane().add(jPanel1);

        jPanel2.setMaximumSize(new java.awt.Dimension(415, 27));
        jPanel2.setPreferredSize(new java.awt.Dimension(415, 28));
        jPanel2.setLayout(new javax.swing.BoxLayout(jPanel2, javax.swing.BoxLayout.X_AXIS));

        jLabel3.setText("  Send. Window");
        jPanel2.add(jLabel3);

        jTextSndWND.setText("0");
        jTextSndWND.setMaximumSize(new java.awt.Dimension(35, 27));
        jTextSndWND.setMinimumSize(new java.awt.Dimension(30, 28));
        jTextSndWND.setPreferredSize(new java.awt.Dimension(35, 28));
        jPanel2.add(jTextSndWND);

        jLabel4.setText("  Recv. Window");
        jPanel2.add(jLabel4);

        jTextRcvWND.setText("1");
        jTextRcvWND.setMaximumSize(new java.awt.Dimension(35, 27));
        jTextRcvWND.setMinimumSize(new java.awt.Dimension(30, 28));
        jTextRcvWND.setPreferredSize(new java.awt.Dimension(35, 28));
        jPanel2.add(jTextRcvWND);

        jComboBoxProtocol.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Utopian Snd", "Utopian Rcv", "Simplex Snd", "Simplex Rcv", "Stop & Wait", "Go-Back-N", "Selec. Repeat" }));
        jComboBoxProtocol.setMaximumSize(new java.awt.Dimension(120, 27));
        jComboBoxProtocol.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBoxProtocolActionPerformed(evt);
            }
        });
        jPanel2.add(jComboBoxProtocol);

        getContentPane().add(jPanel2);

        jPanel3.setLayout(new javax.swing.BoxLayout(jPanel3, javax.swing.BoxLayout.LINE_AXIS));

        jLabel7.setText("Snd Packets");
        jPanel3.add(jLabel7);

        jTextSndPackets.setText("2");
        jTextSndPackets.setMaximumSize(new java.awt.Dimension(70, 27));
        jPanel3.add(jTextSndPackets);

        jLabel8.setText("Timeout");
        jPanel3.add(jLabel8);

        jTextTimeout.setText("23");
        jTextTimeout.setMaximumSize(new java.awt.Dimension(50, 28));
        jPanel3.add(jTextTimeout);

        jLabel9.setText("   Max. Seq. number");
        jPanel3.add(jLabel9);

        jTextMaxSeq.setText("7");
        jTextMaxSeq.setMaximumSize(new java.awt.Dimension(35, 28));
        jPanel3.add(jTextMaxSeq);

        getContentPane().add(jPanel3);

        jPanel4.setLayout(new javax.swing.BoxLayout(jPanel4, javax.swing.BoxLayout.X_AXIS));

        jToggleButtonToFile.setText("Write To File");
        jToggleButtonToFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButtonToFileActionPerformed(evt);
            }
        });
        jPanel4.add(jToggleButtonToFile);

        jTextWriteFile.setText(" ");
        jTextWriteFile.setMaximumSize(new java.awt.Dimension(2147483647, 28));
        jPanel4.add(jTextWriteFile);

        jCheckBoxDebug.setText("Debug");
        jCheckBoxDebug.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxDebugActionPerformed(evt);
            }
        });
        jPanel4.add(jCheckBoxDebug);

        getContentPane().add(jPanel4);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(30);
        jScrollPane1.setViewportView(jTextArea1);

        getContentPane().add(jScrollPane1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Logs a string to the screen and to the file, if opened
     *
     * @param log - log string
     */
    @Override
    public void Log(String log) {
        try {
            System.out.print(log);
            jTextArea1.append(log);
        } catch (Exception ex) 
            {/* Ignore*/}
        if (os != null) {   // Write to file
            try {
                os.write(log + "\n");
            } catch (IOException ex) {
                jTextArea1.append("Error writing to file: " + ex + "\n");
                stop_writing_to_file();
            }
        }
    }

    /**
     * Controls if the configuration text boxes are editable
     *
     * @param editable true if editable, false otherwise
     */
    private void editable_textBoxes(boolean editable) {
        jTextSndWND.setEditable(editable);
        jTextRcvWND.setEditable(editable);
        jTextSndPackets.setEditable(editable);
        jTextTimeout.setEditable(editable);
        jTextMaxSeq.setEditable(editable);
        jComboBoxProtocol.setEditable(editable);
    }

    /**
     * Reads the number of packets to send from the GUI
     *
     * @return the number of packets to send
     */
    public int get_packets() {
        try {
            return Integer.parseInt(jTextSndPackets.getText());
        } catch (Exception e) {
            Log("Invalid number of sending packets: " + jTextSndPackets.getText() + ".\n Using 1\n");
            return 1;
        }
    }

    /**
     * Sets the name of the terminal in the GUI
     *
     * @param name the name of the terminal
     */
    public void set_name(String name) {
        jTextName.setText(name);
    }

    /**
     * Reads the name of the terminal from the GUI
     *
     * @return the name of the terminal
     */
    public String get_name() {
        return jTextName.getText();
    }


    /**
     * Sets the value of the simulation time
     *
     * @param _time the current simulation time
     */
    public void set_timeout_time(long _time) {
        this.time = _time;
    }

    /**
     * Closes all the objects, connections and stops any running simulation
     */
    private void close_all() {
        try {
            editable_textBoxes(true);

            // Stop protocol object
            if (proto != null) {
                // Statistics
                Log("\nConfiguration:\n");
                Log("\tPackets sent:     \t" + get_packets() + "\n");
                Log("\tMax. Seq. Number: \t" + get_max_sequence() + "\n");
                Log("\tSending Window:   \t" + get_send_window() + "\n");
                Log("\tReceiving Window: \t" + get_recv_window() + "\n");
                Log("\tTimeout:          \t" + get_timeout_time() + "\n");

                if (running) {
                    proto.end_simulation(time);
                }
                proto = null;
                ack_timer_on= false;
                timer_on.clear();
                sending_data= false;
                transmitted_data.clear();
            }
            // Stop network object
            if (net != null) {
                // Statistics
                net = null;
            }
            if (conn != null) {
                conn.stopRunning();
                conn = null;
            }
            if (s != null) {
                try {
                    s.close();
                } catch (IOException ex) {
                    // Ignore
                }
                s = null;
            }

            stop_writing_to_file();

            jToggleButtonConnect.setSelected(false);
            jTextName.setText("");
            if (running) {
                running = false;
                Log("\nTerminal stopped\n");
            }
        } catch (Exception e) {
            Log("\nException in close_all: " + e + "\n");
        }
    }

    /**
     * Handles button "Connect" in the GUI that starts/stop the simulations
     *
     * @param evt
     */
    private void jToggleButtonConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButtonConnectActionPerformed
        if (jToggleButtonConnect.isSelected()) {
            // Verify parameters
            if ((get_send_window() + get_recv_window()) > (get_max_sequence() + 1)) {
                Log("Invalid SND window, RCV window or Max sequence\n");
                jToggleButtonConnect.setSelected(false);
                return;
            }
            // Button is ON
            try {
                InetAddress ip = InetAddress.getByName(jTextIP.getText());
                int port = Integer.parseInt(jTextPort.getText());
                s = new Socket(ip, port);
                if (s == null) {
                    throw new Exception("Error creating socket");
                }
                conn = new Connection(this, s);
                net = new NetworkLayer(this);
                switch (jComboBoxProtocol.getSelectedIndex()) {
                    case 0: // Utopian protocol - sender
                        proto = new Utopian_snd(this, net);
                        break;
                    case 1: // Utopian protocol - receiver only
                        jTextSndPackets.setText("0");
                        proto = new Utopian_rcv(this, net);
                        break;
                    case 2: // Simplex protocol - sender
                        proto = new Simplex_snd(this, net);
                        break;
                    case 3: // Simplex protocol - receiver only
                        jTextSndPackets.setText("0");
                        proto = new Simplex_rcv(this, net);
                        break;
                    case 4: // Stop&Wait protocol
                        proto = new StopWait(this, net);
                        break;
                    case 5: // Go-back-N protocol
                        proto = new GoBackN(this, net);
                        break;
                    case 6: // Selective repeat protocol
                        proto = new SelectiveRepeat(this, net);
                        break;
                    default:
                        Log("Protocol " + (jComboBoxProtocol.getSelectedIndex() + 1) + " not implemented yet\n");
                }
                if (proto != null) {
                    conn.start();
                    running = true;
                    editable_textBoxes(false);
                    Log("Terminal started\n");
                } else {
                    close_all();
                }
            } catch (Exception e) {
                Log("Error connecting to channel\n");
                jToggleButtonConnect.setSelected(false);
            }

        } else {
            // Button is OFF
            close_all();
        }
    }//GEN-LAST:event_jToggleButtonConnectActionPerformed

    /**
     * Handles the button "Clear"; clears the log window
     *
     * @param evt
     */
    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
        jTextArea1.setText("");
    }//GEN-LAST:event_jButtonClearActionPerformed

    /**
     * Turns ON/OFF the debug mode, controling the amount of information logged
     *
     * @param evt
     */
    private void jCheckBoxDebugActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxDebugActionPerformed
        Terminal.debug = jCheckBoxDebug.isSelected();
    }//GEN-LAST:event_jCheckBoxDebugActionPerformed

    /**
     * Handles the "Write to File" buttons that controls the writing of the log
     * to a file
     *
     * @param evt
     */
    private void jToggleButtonToFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButtonToFileActionPerformed
        if (jToggleButtonToFile.isSelected()) {
            if (!start_writing_to_file()) {
                jToggleButtonToFile.setSelected(false);
            }
        } else {
            stop_writing_to_file();
        }
    }//GEN-LAST:event_jToggleButtonToFileActionPerformed

    /**
     * Handles the closing of the main window, ending all ongoing simulation
     *
     * @param evt
     */
    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        close_all();
    }//GEN-LAST:event_formWindowClosing

    /**
     * Intercepts the selection of a new protocol and defines default compatible
     * window sizes
     *
     * @param evt
     */
    private void jComboBoxProtocolActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBoxProtocolActionPerformed
        int n = jComboBoxProtocol.getSelectedIndex();
        int maxs = this.get_max_sequence();
        switch (n) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                jTextSndWND.setText("1");
                jTextRcvWND.setText("1");
                break;
            case 5:
                jTextSndWND.setText("" + maxs);
                jTextRcvWND.setText("1");
                break;
            case 6:
                jTextSndWND.setText("" + ((maxs + 1) / 2));
                jTextRcvWND.setText("" + ((maxs + 1) / 2));
                break;
        }
    }//GEN-LAST:event_jComboBoxProtocolActionPerformed
            
    /**
     * Calback function that is called when a new message is received from the
     * channel socket. It parses the message received and generates an event to
     * the protocol object.
     *
     * @param message string received in the socket
     */
    void receive_message(String message) {
        Event ev = new Event(this, Event.UNDEFINED_EVENT, time);
        if (ev.str_to_event(message, this)) {
            time = ev.time();
            if (Terminal.debug) {
                Log(time + " Received from channel: " + ev + "\n");
            } else {
                System.out.println(time + " Received from channel: " + ev);
            }
            // Receive a valid event
            switch (ev.kind()) {
                case Event.TIME_EVENT:
                    if (time == 0) {
                        // Start the simulation
                        proto.start_simulation(time);
                    }
                    break;
                case Event.DATA_END:
                    sending_data= false;
                    Log(time + " Data End ("+ev.key()+")\n");
                    proto.handle_Data_end(time, ev.key());
                    break;
                case Event.TIMER_EVENT:
                    if (ev.key() == ACK_TIMER_ID) {
                        if (ack_timer_on) {
                            ack_timer_on = false;   // Turns flag off before calling callback
                            Log(time + " Ack Timeout ()\n");
                            proto.handle_ack_Timer(time);
                        }
                    } else {
                        if (timer_on.containsKey(ev.key())) {
                            if (ev.key() != DATA_TIMER_ID) {
                                // Using a single ID timer!
                                return;
                            }
                            timer_on.remove(ev.key());
                            // Call handle_event
                            // Log(time + " Data Timeout ("+ev.key()+")\n");
                            Log(time + " Data Timeout ()\n");
                            // proto.handle_Data_Timer(time, ev.key());
                            proto.handle_Data_Timer(time);
                        }
                    }
                    break;
                case Event.START_TIMER:
                    Log("Channel cannot send START_TIMER events\n");
                    close_all();
                    return;
                case Event.FRAME_EVENT:
                    if (ev.frame().seq() > get_max_sequence()) {
                        Log(time + " Received from channel Data with invalid sequence number: "
                                + ev.frame().toString() + "\n");
                        close_all();
                        return;
                    }
                    ev.frame().set_recvTime(time);
                    
                    Log(time + " Frame received: " + ev.frame().toString() + "\n");
                    
                    // Test repeated NAK
                    if (ev.frame().kind() == Frame.NAK_FRAME) {
                        if (ev.frame().ack() == last_nak) {
                            Log(time + " Nak ("+last_nak+") REPEATED!\n");
                        } else
                            last_nak= ev.frame().ack();
                    } else {
                        if (ev.frame().ack() != last_nak) {
                            // Ack changed
                            last_nak= -1;
                        }
                    }
                    
                    // Call handle_event
                    proto.from_physical_layer(time, ev.frame());
                    break;
                case Event.STOP_EVENT:
                    close_all();
                    return;
                case Event.REQ_CONFIG:
                    Event cev = Event.new_Configuration_Event(this, time,
                            jComboBoxProtocol.getSelectedIndex(),
                            get_max_sequence(), get_send_window(),
                            get_recv_window(), get_timeout_time(), get_packets());
                    if (!conn.send_message(cev.event_to_str())) {
                        Log("Error sending message to channel\n");
                        close_all();
                        return;
                    }
                    break;
                default:
                    Log("Invalid kind of event (" + ev.kind() + ")\n");
                    close_all();
                    return;
            }
        } else {
            Log("Error parsing received message\n");
            close_all();
            return;
        }

        // Signal that finished processing the request
        Event eev = Event.new_End_Event(this);
        if (!conn.send_message(eev.event_to_str())) {
            Log("Error sending message to channel\n");
            close_all();
        }
    }

    /**
     * Method called by the Connection thread when the TCP connection ends
     *
     * @param aThis
     */
    void connection_thread_ended(Connection aThis) {
        conn = null;
        close_all();
    }

    /* ********************************************************** *\
     * The following functions implement the Simulator interface  *
     * functions, that interface the GUI                          *
     */
    /**
     * Reads from the GUI the sending window size
     *
     * @return the sending window size
     */
    @Override
    public int get_send_window() {
        try {
            return Integer.parseInt(jTextSndWND.getText());
        } catch (Exception e) {
            Log("Invalid send window value: " + jTextSndWND.getText() + ".\n Using 1\n");
            return 1;
        }
    }

    /**
     * Reads from the GUI the receiving window size
     *
     * @return the receiving window size
     */
    @Override
    public int get_recv_window() {
        try {
            return Integer.parseInt(jTextRcvWND.getText());
        } catch (Exception e) {
            Log("Invalid receive window value: " + jTextRcvWND.getText() + ".\n Using 1\n");
            return 1;
        }
    }

    /**
     * Reads from the GUI the maximum sequence number
     *
     * @return the maximum sequence number
     */
    @Override
    public int get_max_sequence() {
        try {
            return Integer.parseInt(jTextMaxSeq.getText());
        } catch (Exception e) {
            Log("Invalid receive window value: " + jTextMaxSeq.getText() + ".\n Using 1\n");
            return 1;
        }
    }

    /**
     * Reads from the GUI the Data timeout time
     *
     * @return the data timeout time
     */
    @Override
    public long get_timeout_time() {
        try {
            return Long.parseLong(jTextTimeout.getText());
        } catch (Exception e) {
            Log("Invalid send window value: " + jTextTimeout.getText() + ".\n Using 10\n");
            return 10;
        }
    }

    /**
     * Returns the current simulation time manage by the Terminal class
     *
     * @return the current time
     */
    @Override
    public long get_time() {
        return time;
    }

    /**
     * Auxiliary function used to send statistical information to the channel
     *
     * @param key the statistical variable
     */
    public void count_statistics(int key) {
        try {
            Event ev = Event.new_Stat_Event(this, time, key);
            if (Terminal.debug) {
                System.out.println(time + " Sending stat: " + key);
            }
            String txt = ev.event_to_str();
            conn.send_message(txt);
        } catch (Exception ex) {
            Log("Error in count_statistics: " + ex + "\n");
        }
    }

    /**
     * Start the DATA timer.
     */
    @Override
    public void start_data_timer() {
        start_timer(DATA_TIMER_ID);
    }
    
    /**
     * Restart the DATA timer.
     */
    @Override
    public void restart_data_timer() {
        if (isactive_data_timer())
            cancel_data_timer();
        start_data_timer();
    }
    
    /**
     * Start a timer for delay, associated to key "key"
     *
     * @param key a number equal to or above 0
     */
    public void start_timer(int key) {
        try {
            long delay = get_timeout_time();
            if (delay < 0) {
                Log(time + " INVALID start_data_timer: delay must be >= 0\n");
                return;
            }

            Event ev = Event.new_Start_Timer(this, time, key, delay);
            if (key >= 0) {
                if (key == DATA_TIMER_ID)
                    Log(time + " start_data_timer (" + delay + ")\n");
                else
                    Log(time + " start_timer (" + key + "," + delay + ")\n");
            } else {
                Log(time + " INVALID start_timer: key must be >= 0\n");
                return;
            }
            timer_on.put(key, time);
            String txt = ev.event_to_str();
            conn.send_message(txt);
        } catch (Exception ex) {
            Log("Error in start_timer: " + ex + "\n");
        }
    }

    /**
     * Cancel the DATA timer
     */
    @Override
    public void cancel_data_timer() {
        cancel_timer(DATA_TIMER_ID);
    }

    /**
     * Cancel the timer associated with key "key"
     *
     * @param key
     */
    public void cancel_timer(int key) {
        try {
            Event ev = Event.new_Start_Timer(this, time, key, ACK_TIMER_ID);
            if (key >= 0) {
                if (timer_on.containsKey(key)) {
                    timer_on.remove(key);
                    if (key == DATA_TIMER_ID)
                        Log(time + " cancel_data_timer ()\n");
                    else
                        Log(time + " cancel_timer (" + key + ")\n");
                        
                    String txt = ev.event_to_str();
                    conn.send_message(txt);
                }
            } else {
                Log(time + " INVALID cancel_timer: key must be >= 0\n");
            }
        } catch (Exception ex) {
            Log("Error in cancel_timer: " + ex + "\n");
        }
    }

    /**
     * Test is Data timer is active
     * @param key
     */
    @Override
    public boolean isactive_data_timer() {
        return timer_on.containsKey(DATA_TIMER_ID);
    }

    /**
     * Test if timer with key "key" is active
     * @param key
     */
    public boolean isactive_timer(int key) {
        return timer_on.containsKey(key);
    }

    /**
     * Starts an ACK timer to wait for the transmission of a data frame before
     * sending the ACK
     */
    @Override
    public void start_ack_timer() {
        try {
            Event ev = Event.new_Start_Timer(this, time, ACK_TIMER_ID, ACK_TIMEOUT);
            Log(time + " start_ack_timer (" + ACK_TIMEOUT + ")\n");
            String txt = ev.event_to_str();
            conn.send_message(txt);
            ack_timer_on = true;
        } catch (Exception ex) {
            Log("Error in start_ack_timer: " + ex + "\n");
        }
    }

    /**
     * Cancels the ACK timer
     */
    @Override
    public void cancel_ack_timer() {
        if (ack_timer_on) {
            ack_timer_on = false;
            try {
                Event ev = Event.new_Start_Timer(this, time, ACK_TIMER_ID, -1);
                Log(time + " Cancel_ack_timer\n");
                String txt = ev.event_to_str();
                conn.send_message(txt);
            } catch (Exception ex) {
                Log("Error in cancel_ack_timer: " + ex + "\n");
            }
        }
    }

    /**
     * Tests if the ack timer is active
     * @return true if it is active, false otherwise
     */
    @Override
    public boolean isactive_ack_timer() {
        return ack_timer_on;
    }

    /**
     * TRansmits a frame to the channel
     *
     * @param frame the frame to be transmitted
     */
    @Override
    public void to_physical_layer(Frame frame) {
        try {
            frame.set_sendTime(time);
            Event ev = Event.new_Frame_Event(this, time, frame);
            Log(time + " Sending frame: " + frame.toString() + "\n");
            String txt = ev.event_to_str();
            conn.send_message(txt);
            if (frame.kind() == Frame.DATA_FRAME) {
                sending_data= true;
                Integer last= transmitted_data.get(frame.info());
                if (last != null) {
                    count_statistics(Event.STAT_RETRANSMITED);
                    if (last != frame.seq()) {
                        Log("ERROR: '"+frame.info()+"' transmitted with seq="+
                                last+" and seq="+frame.seq()+"\n");
                    }
                } else {
                    transmitted_data.put(frame.info(), frame.seq());
                }
            }
        } catch (Exception ex) {
            Log("Error in to_physical_layer: " + ex + "\n");
        }
    }

    /**
     * Test if is sending a DATA frame
     * @return true if is sending, false otherwise
     */
    @Override
    public boolean is_sending_data() {
        return sending_data;
    }

    /**
     * Send a Stop event to the channel to stop the simulation
     */
    @Override
    public void stop() {
        try {
            Event ev = Event.new_Stop_Event(this);
            if (Terminal.debug) {
                Log(time + " Sending stop\n");
            } else {
                System.out.println(time + " Sending stop\n");
            }
            String txt = ev.event_to_str();
            conn.send_message(txt);
        } catch (Exception ex) {
            Log("Error in stop: " + ex + "\n");
        }
    }

    /**
     * Start recording operations to a file; Pick a name and open file for
     * writing
     *
     * @return true if success, false otherwise
     */
    private boolean start_writing_to_file() {
        try {
            // Start writing
            if (jFileChooser1.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
                f = jFileChooser1.getSelectedFile();
                Log("Writing to: " + f + "\n");
                os = new BufferedWriter(new OutputStreamWriter(
                        new FileOutputStream(f), "8859_1"));
                jTextWriteFile.setText(f.getAbsolutePath());
                return true;
            }
        } catch (Exception e) {
            System.err.println("Error selecting output file: " + e);
        }
        return false;
    }

    /**
     * Stop recording and close file
     */
    private void stop_writing_to_file() {
        try {
            if (os != null) {
                // Close file writing device 
                //     and free memory setting references to null
                os.close();
                os = null;
                f = null;
                Log("Stopped writing\n");
            }
        } catch (Exception e) {
            // Ignore
            System.err.println("Error: " + e);
        }
        jTextWriteFile.setText("");
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Terminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Terminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Terminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Terminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new Terminal().setVisible(true);
            }
        });
    }
    /**
     * Static variable to control debug
     */
    public static boolean debug = false;
    /**
     * Simulation is running
     */
    private boolean running;
    /**
     * TCP Socket connected to the channel
     */
    private Socket s;
    /**
     * Thread that manages the TCP connection
     */
    private Connection conn;
    /**
     * Current simulation time
     */
    private long time;
    /**
     * Callback interface to the protocol object
     */
    private Callbacks proto;
    /**
     * Network layer object
     */
    private NetworkLayer net;
    /**
     * Flag associated to ack timer
     */
    private boolean ack_timer_on;
    private final HashMap<Integer, Long> timer_on;
    /**
     * Flag associated to sending data 
     */
    private boolean sending_data;
    /**
     * List to detect retransmitted packets
     */
    private final HashMap<String,Integer> transmitted_data;
    /**
     * Last nak received (-1 none) - to detect errors implementing NAK
     */
    private int last_nak;
    
    /* Variables for log to a file */
    /**
     * File object for logging into a file
     */
    private File f;
    /**
     * File writting object
     */
    private BufferedWriter os;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClear;
    private javax.swing.JCheckBox jCheckBoxDebug;
    private javax.swing.JComboBox jComboBoxProtocol;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextIP;
    private javax.swing.JTextField jTextMaxSeq;
    private javax.swing.JTextField jTextName;
    private javax.swing.JTextField jTextPort;
    private javax.swing.JTextField jTextRcvWND;
    private javax.swing.JTextField jTextSndPackets;
    private javax.swing.JTextField jTextSndWND;
    private javax.swing.JTextField jTextTimeout;
    private javax.swing.JTextField jTextWriteFile;
    private javax.swing.JToggleButton jToggleButtonConnect;
    private javax.swing.JToggleButton jToggleButtonToFile;
    // End of variables declaration//GEN-END:variables
}
